
# EXTERNAL TEMP
import {{Name}}AirtableData from 

let {{lower}} = await {{name}}s.({{lower}})
let {{lower}} = await {{name}}s.findByID(id)
await {{name}}s.update({{lower}})
await {{name}}s.delete({{lower}})
await {{name}}s.truncate()






import { RemoteDataSource } from "../../../type";
import { {{name}} } from "../../models/{{lower}}";

import airtable from './airtable-plus-rest-dao-config';
import { create } from 'domain'

const config = { tableName: '{{name}}s' } 

export class {{name}}AirtableData implements RemoteDataSource<{{name}}>{
 
    async create(json:object){
        const res = await airtable.create(json,config)
    }
 
  async create_ten(projects: Project[]): Promise<void> {
    var Airtable = require('airtable');
    const dotenv = require('dotenv');
    dotenv.config()
    var base = new Airtable({ apiKey: process.env.apiKey }).base(process.env.base);
    let airtable_formatted_list: any = []
    {{lower}}s.forEach({{lower}} => {
      const fields: { [key: string]: any } = {
          {{#attrs}}
           {{name}}: {{lower}}.{{name}},
          {{/attrs}}
      }
      airtable_formatted_list.push({ "fields": fields })
    });

    return new Promise(resolve => {
      base('ProjectReportsPerPaymentTypes').create(airtable_formatted_list, function (err: any) {
        if (err) {
          console.error(err);
          return;
        }
        resolve()
      });
    })
  }


    async findByID(id:string){
        const res = await airtable.find(id);
        return res
    }
    fromData(row: any): {{name}} { 
        return new {{name}}(
            {{#attrs}}
            row.{{name}},
            {{/attrs}}
        );
    }
    async fetch(): Promise<{{name}}[]> {
        return []
      }
    

    {{#attrs}}
    async findBy{{name}}({{name}}:{{type}}){
        const readRes = await airtable.read({
            filterByFormula: '{{upper}} = '+{{name}},
            maxRecords: 1
        });
        this.jsonObject = {}
        var jsonObject = require(file_path)
        return jsonObject
    }
    {{/attrs}}
    
    {{#attrs}} // this is for OF restriction. 
    async of{{upper}}({{name}}){ 
        const readRes = await airtable.read({
            filterByFormula: '{{upper}} = '+{{name}},
            maxRecords: 500
        });
        {{lower}}s = readRes // ? this must be more like the 
        return {{lower}}s
    }
    {{/attrs}}
    


    async update(id:string,json:object):Promise<void>{
        const updateRes = await airtable.update(id, { 
            Name: 'foobar'
        }, config);
        return updateRes
    }

    async delete(id:string){
        const deleteRes = await airtable.delete(id,config);
    }





  async _readAll(): Promise<object[]> {
    const readRes = await airtable.read({
      fields:['id']
    },config);
    return readRes
  }


  async truncate(): Promise<void> {
    let {{lower}}s = await this._readAll()


    let ids_pack: string[] = new Array()
    let packs: object[] = new Array()
    for (let index = 0; index < {{lower}}s.length; index++) {
      //@ts-ignore
      ids_pack.push({{lower}}s[index].id)

      if (ids_pack.length === 10) {
        packs.push(ids_pack)
        ids_pack = new Array()
      }
    }

    require('array-foreach-async');
    const delete_ten = this.delete_ten
    //@ts-ignore
    await packs.forEachAsync(async function ({{lower}}sPack: Project[]) {
      //@ts-ignore
      await delete_ten({{lower}}sPack)
    })
  }
  async delete_ten(ids: string[]): Promise<void> {
    console.log("deleting 10 from airtable --")
    var Airtable = require('airtable');
    const dotenv = require('dotenv');
    dotenv.config()
    var base = new Airtable({ apiKey: process.env.apiKey }).base(process.env.base);

    return new Promise(resolve => {
      try {
        base('{{name}}s').destroy(ids, function (err: any) {
          console.log(err)
          resolve()
        });
      } catch (error) {
        console.log(error)
      }
    })
  }



}
